<!DOCTYPE html>
<html ng-app="">

  <head>
    <title>Cloudify's Build Dashboard</title>
    <script data-require="angular.js@1.2.22" data-semver="1.2.22" src="https://code.angularjs.org/1.2.22/angular.js"></script>
    <script data-require="lodash.js@2.4.1" data-semver="2.4.1" src="http://cdnjs.cloudflare.com/ajax/libs/lodash.js/2.4.1/lodash.js"></script>
    <link rel="stylesheet" href="style.css" />
  </head>

  <body ng-controller="TravisCtrl">
    <div id="header">
      Cloudify's Build Dashboard
      <span>Updated at: {{ updatedAt }}</span>
    </div>
    <div id="wrapper">
      <span class="branch">master</span>
          <div ng-repeat="d in data track by d.displayName" ng-if="d.ci == 'circle'" class="report {{ d.lifecycle }}">
              <a href='{{d.circleBuildLink}}'>{{ d.displayName }}</a>
              <div>{{ d.customText }}</div>
          </div>

          <div ng-repeat="d in data track by d.displayName" ng-if="d.ci == 'travis'" class="report {{ d.state }}">
              <a href='{{d.travisBuildLink}}'>{{ d.displayName }}</a>
              <div>{{ d.customText }}</div>
          </div>
    </div>
    <!-- <div id="builds">
      <span class="branch">build</span>
      <div ng-repeat="d in builds track by d.name" class="report {{ d.state }}">
        <a href='{{d.travisBuildLink}}'>{{ d.displayName }}</a>
        <div>{{ d.customText }}</div>
      </div>
    </div>-->
    <div id="disabled">
      <div ng-repeat="repo in disabled track by repo.displayName" class="disabled report">
        {{ repo.displayName }}
      </div>
    </div>
    <script>
      function getCurrentTime() {
        var date = new Date();
        var options = {
          hour12: false,
        };
        return date.toLocaleTimeString('en-us', options).substring(0, 5);
      }
      function TravisCtrl($http, $scope, $timeout, $log) {
        var repositories = [
          ['cloudify-cosmo/cloudify-manager', 'circle'],
          ['cloudify-cosmo/cloudify-cli', 'circle'],
          ['cloudify-cosmo/cloudify-dsl-parser', 'circle'],
          ['cloudify-cosmo/cloudify-rest-client', 'circle'],
          ['cloudify-cosmo/cloudify-diamond-plugin', 'circle'],
          ['cloudify-cosmo/cloudify-docker-plugin', 'circle'],
          ['cloudify-cosmo/cloudify-cloudstack-plugin', 'circle'],
          ['cloudify-cosmo/cloudify-script-plugin', 'circle'],
          ['cloudify-cosmo/cloudify-chef-plugin', 'circle'],
          ['cloudify-cosmo/cloudify-puppet-plugin', 'circle'],
          ['cloudify-cosmo/cloudify-openstack-plugin', 'circle'],
          ['cloudify-cosmo/cloudify-plugins-common', 'circle'],
          ['cloudify-cosmo/cloudify-fabric-plugin', 'circle'],
          ['cloudify-cosmo/cloudify-amqp-influxdb', 'circle'],
          ['cloudify-cosmo/cloudify-system-tests', 'circle'],
          ['cloudify-cosmo/cloudify-plugin-template', 'circle'],
          ['cloudify-cosmo/cloudify-agent-packager', 'circle'],
          ['cloudify-cosmo/version-tool', 'circle'],
          ['cloudify-cosmo/cloudify-nodecellar-example', 'circle'],
          ['cloudify-cosmo/cloudify-manager-blueprints', 'circle'],
          ['cloudify-cosmo/packman', 'circle'],
          ['cloudify-cosmo/repex', 'circle'],
          ['cloudify-cosmo/cloudify-agent', 'circle'],
          ['hello-world-example', 'circle', 'cloudify-cosmo/cloudify-manager-blueprints', 'master'],
          ['cloudify-cosmo/flask-securest', 'travis'],
          ['Bootstrap Sanity', 'travis', 'cloudify-cosmo/cloudify-manager-blueprints', 'bootstrap-sanity']
        ];
        repos = _.map(repositories, function(name) {
          repo_name = name[0];
          title = name[0];
          ci = name[1];
          branch = 'master';
          if (name.length > 2) {
            title = name[0];
            ci = name[1];
            repo_name = name[2];
            branch = name[3];
          }
        return {
            'name': repo_name,
            'displayName': title.replace('cloudify-cosmo/', ''),
            'travisBuildLink': '',
            'travisApiLink': 'https://api.travis-ci.org/repos/' + repo_name + '/builds?event_type=push',
            'circleBuildLink': '',
            'circleApiLink': 'https://circleci.com/api/v1/project/' + repo_name + '/tree/master',
            'state': 'uninitialized',
            'customText': '0s',
            'buildsPage': 0,
            'branch': branch,
            'ci': ci
        };
      });
        function isBuildBranch(branchName) {
            var regexp = new RegExp(/^\d*\.\d*.*/);
            return regexp.exec(branchName) != null && branchName.lastIndexOf('build') == -1;
        }
        function processRepoResponse(repo, response) {
          if (repo.ci == 'travis'){
            var builds = _.filter(response.data, function(build) {
              return (build.branch == repo.branch) && !(build.state === 'finished' && build.duration == 0);
            });
            builds = builds.sort(function(x, y) {
              if (x.started_at == null) {
                return -1;
              } else if (y.started_at == null) {
                return 1;
              }
              var xStartedAt = new Date(x.started_at);
              var yStartedAt = new Date(y.started_at);
              if (xStartedAt < yStartedAt) {
                return 1;
              } else if (yStartedAt < xStartedAt) {
                return -1;
              }
              return 0;
            });
            if (builds.length == 0) {
              if (response.data.length > 0 && repo.buildsPage < 10) {
                repo.buildsPage += 1;
                lastNumber = response.data[response.data.length-1].number;
                paramConcatIndex = repo.travisApiLink.lastIndexOf("&")
                if (paramConcatIndex != -1)
                  repo.travisApiLink = repo.travisApiLink.substring(0, paramConcatIndex);
                repo.travisApiLink += "&after_number=" + lastNumber;
                loadStatus(repo);
              }
              repo.state = 'not-running';
              return null;
              }
              var build = builds[0];
              repo.branch = build.branch;
              repo.travisBuildLink = 'https://travis-ci.org/' + repo.name + '/builds/' + build.id
              repo.state = build.state;
              if (build.state == 'created') {
                repo.customText = '0s';
              } else if (build.state == 'started') {
                var startedAt = new Date(build.started_at);
                var currentTime = new Date();
                repo.customText = Math.max(0, Math.round((currentTime.getTime() - startedAt.getTime()) / 1000)) + 's';
              } else if (build.state == 'finished' && build.result != 0) {
                  repo.state = 'failed'
              }
            return build;}
          if (repo.ci == 'circle'){
              var builds = _.filter(response.data, function(build) {
                  return (build.branch == repo.branch || build.vcs_tag == 'bootstrap-sanity') && !(build.lifecycle === 'finished' && build.build_time_millis == 0);
              });
              builds = builds.sort(function(x, y) {
                  if (x.started_time == null) {
                      return -1;
                  } else if (y.started_time == null) {
                      return 1;
                  }
                  var xStartedAt = new Date(x.started_time);
                  var yStartedAt = new Date(y.started_time);
                  if (xStartedAt < yStartedAt) {
                      return 1;
                  } else if (yStartedAt < xStartedAt) {
                      return -1;
                  }
                  return 0;
              });
              if (builds.length == 0) {
                  if (response.data.length > 0 && repo.buildsPage < 10) {
                      repo.buildsPage += 1;
                      lastNumber = response.data[response.data.length-1].number;
                      paramConcatIndex = repo.circleApiLink.lastIndexOf("&")
                      if (paramConcatIndex != -1)
                          repo.circleApiLink = repo.circleApiLink.substring(0, paramConcatIndex);
                      repo.circleApiLink += "&after_number=" + lastNumber;
                      loadStatus(repo);
                  }
                  repo.lifecycle = 'not_running';
                  return null;
              }
              var build = builds[0];
              repo.branch = build.branch;
              repo.circleBuildLink = 'https://circleci.com/gh/' + repo.name + '/' + build.build_num
              repo.lifecycle = build.lifecycle;
              if (build.lifecycle == 'scheduled') {
                  repo.customText = '0s';
              } else if (build.lifecycle == 'running') {
                  var startedAt = new Date(build.start_time);
                  var currentTime = new Date();
                  repo.customText = Math.max(0, Math.round((currentTime.getTime() - startedAt.getTime()) / 1000)) + 's';
              } else if (build.lifecycle == 'finished' && build.status == 'failed') {
                  repo.lifecycle = 'failed'
              }
              return build;
          }
        }
        // DEBUG
        // states = ['uninitialized', 'created', 'started', 'finished', 'failed', 'not-running'];
        // for (var i = 0; i < repos.length; i++) {
        //   var number = Math.floor(Math.random() * 100);
        //   repos[i].state = states[number % states.length];
        // }
        $scope.data = repos.sort(function(x, y) {
          return x.displayName.localeCompare(y.displayName);
        });
        $scope.builds = [];
        $scope.disabled = [];
        $scope.updatedAt = getCurrentTime();
        function loadStatus(repo) {
            if (repo.ci == 'travis'){
              $log.info('making request to: ' + repo.travisApiLink);
              var timeout = 60000;
              $http.get(repo.travisApiLink).then(function(response) {
                  var build = processRepoResponse(repo, response);
                  if (build) {
                    $log.info('build: ' + JSON.stringify(build));
                    if (build.state == 'started' || build.state == 'created') {
                      timeout = 10000;
                    }
                  }
                  $scope.data = repos.filter(function(r) {
                    return r.state != 'not-running';
                  });
                  $scope.builds = repos.filter(function(r) {
                    return r.state != 'not-running' && isBuildBranch(r.branch);
                  });
                  $scope.disabled = repos.filter(function(r) {
                    return r.state == 'not-running';
                  });
                  $scope.updatedAt = getCurrentTime();
                  if (repo.state != 'not-running') {
                    $timeout(function() {
                      loadStatus(repo);
                    }, timeout);
                  }
              }, function(result) {
                $log.error('unable to get results for: ' + repo);
                $timeout(function() {
                  loadStatus(repo);
                }, timeout);
              });}
        if (repo.ci == 'circle'){
              $log.info('making request to: ' + repo.circleApiLink);
              var timeout = 60000;
              $http.get(repo.circleApiLink).then(function(response) {
                  var build = processRepoResponse(repo, response);
                  if (build) {
                      $log.info('build: ' + JSON.stringify(build));
                      if (build.lifecycle == 'running' || build.lifecycle == 'scheduled') {
                          timeout = 10000;
                      }
                  }
                  $scope.data = repos.filter(function(r) {
                      return r.lifecycle != 'not_running';
                  });
                  $scope.builds = repos.filter(function(r) {
                      return r.lifecycle != 'not_running' && isBuildBranch(r.branch);
                  });
                  $scope.disabled = repos.filter(function(r) {
                      return r.lifecycle == 'not_running';
                  });
                  $scope.updatedAt = getCurrentTime();
                  if (repo.lifecycle != 'not_running') {
                      $timeout(function() {
                          loadStatus(repo);
                      }, timeout);
                  }
              }, function(result) {
                  $log.error('unable to get results for: ' + repo);
                  $timeout(function() {
                      loadStatus(repo);
                  }, timeout);
              });}
          }
        for ( var i = 0; i < repositories.length; i ++) {
          loadStatus(repos[i]);
        }
      }
    </script>
  </body>

</html>