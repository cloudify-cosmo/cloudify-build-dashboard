<!DOCTYPE html>
<html ng-app="">

  <head>
    <title>Cloudify's Build Dashboard</title>
    <script data-require="angular.js@1.2.22" data-semver="1.2.22" src="https://code.angularjs.org/1.2.22/angular.js"></script>
    <script data-require="lodash.js@2.4.1" data-semver="2.4.1" src="http://cdnjs.cloudflare.com/ajax/libs/lodash.js/2.4.1/lodash.js"></script>
    <link rel="stylesheet" href="style.css" />
  </head>

  <body ng-controller="CircleCtrl">
    <div id="header">
      Cloudify's Build Dashboard - Circleci
      <span>Updated at: {{ updatedAt }}</span>
    </div>
    <div id="wrapper">
      <span class="branch">master</span>
      <div ng-repeat="d in data track by d.displayName" class="report {{ d.lifecycle }}">
        <a href='{{d.circleBuildLink}}'>{{ d.displayName }}</a>
        <div>{{ d.customText }}</div>
      </div>
    </div>
    <!-- <div id="builds">
      <span class="branch">build</span>
      <div ng-repeat="d in builds track by d.name" class="report {{ d.lifecycle }}">
        <a href='{{d.circleBuildLink}}'>{{ d.displayName }}</a>
        <div>{{ d.customText }}</div>
      </div>
    </div>-->
    <div id="disabled">
      <div ng-repeat="repo in disabled track by repo.displayName" class="disabled report">
        {{ repo.displayName }}
      </div>
    </div>
    <script>
      function getCurrentTime() {
        var date = new Date();
        var options = {
          hour12: false,
        };
        return date.toLocaleTimeString('en-us', options).substring(0, 5);
      }

      function CircleCtrl($http, $scope, $timeout, $log) {

        var repositories = [
          'cloudify-cosmo/cloudify-manager',
          'cloudify-cosmo/cloudify-cli',
          'cloudify-cosmo/cloudify-dsl-parser',
          'cloudify-cosmo/cloudify-rest-client',
          'cloudify-cosmo/cloudify-diamond-plugin',
          'cloudify-cosmo/cloudify-docker-plugin',
          'cloudify-cosmo/cloudify-cloudstack-plugin',
          'cloudify-cosmo/cloudify-script-plugin',
          'cloudify-cosmo/cloudify-chef-plugin',
          'cloudify-cosmo/cloudify-puppet-plugin',
          'cloudify-cosmo/cloudify-openstack-plugin',
          'cloudify-cosmo/cloudify-plugins-common',
          'cloudify-cosmo/cloudify-fabric-plugin',
          'cloudify-cosmo/cloudify-amqp-influxdb',
          'cloudify-cosmo/cloudify-system-tests',
          'cloudify-cosmo/cloudify-plugin-template',
          'cloudify-cosmo/cloudify-agent-packager',
          'cloudify-cosmo/version-tool',
          'cloudify-cosmo/cloudify-nodecellar-example',
          'cloudify-cosmo/cloudify-manager-blueprints',
          'cloudify-cosmo/packman',
          'cloudify-cosmo/repex',
          'cloudify-cosmo/cloudify-agent',
          ['Bootstrap Sanity', 'cloudify-cosmo/cloudify-manager-blueprints', 'bootstrap-sanity']
        ];

        repos = _.map(repositories, function(name) {
          repo_name = name;
          title = name;
          branch = 'master';
          if (repo_name instanceof Array) {
            repo_name = name[1];
            title = name[0];
            branch = name[2];
          }
          return {
            'name': repo_name,
            'displayName': title.replace('cloudify-cosmo/', ''),
            'circleBuildLink': '',
            'circleApiLink': 'https://circleci.com/api/v1/project/' + repo_name,
            'lifecycle': 'uninitialized',
            'customText': '0s',
            'buildsPage': 0,
            'branch': branch
          };
        });

        function isBuildBranch(branchName) {
            var regexp = new RegExp(/^\d*\.\d*.*/);
            return regexp.exec(branchName) != null && branchName.lastIndexOf('build') == -1;
        }

        function processRepoResponse(repo, response) {
          var builds = _.filter(response.data, function(build) {
            return (build.branch == repo.branch || build.vcs_tag == 'bootstrap-sanity') && !(build.lifecycle === 'finished' && build.build_time_millis == 0);
          });

          builds = builds.sort(function(x, y) {
            if (x.started_time == null) {
              return -1;
            } else if (y.started_time == null) {
              return 1;
            }
            var xStartedAt = new Date(x.started_time);
            var yStartedAt = new Date(y.started_time);
            if (xStartedAt < yStartedAt) {
              return 1;
            } else if (yStartedAt < xStartedAt) {
              return -1;
            }
            return 0;
          });

          if (builds.length == 0) {
            if (response.data.length > 0 && repo.buildsPage < 10) {
              repo.buildsPage += 1;
              lastNumber = response.data[response.data.length-1].number;
              paramConcatIndex = repo.circleApiLink.lastIndexOf("&")
              if (paramConcatIndex != -1)
                repo.circleApiLink = repo.circleApiLink.substring(0, paramConcatIndex);
              repo.circleApiLink += "&after_number=" + lastNumber;
              loadStatus(repo);
            }

            repo.lifecycle = 'not_running';
            return null;
          }
          var build = builds[0];
          repo.branch = build.branch;
          repo.circleBuildLink = 'https://circleci.com/gh/' + repo.name + '/' + build.build_num
          repo.lifecycle = build.lifecycle;
          if (build.lifecycle == 'scheduled') {
            repo.customText = '0s';
          } else if (build.lifecycle == 'running') {
            var startedAt = new Date(build.started_time);
            var currentTime = new Date();
            repo.customText = Math.max(0, Math.round((currentTime.getTime() - startedAt.getTime()) / 1000)) + 's';
          } else if (build.lifecycle == 'finished' && build.status == 'failed') {
              repo.lifecycle = 'failed'
          }
          return build;
        }

        // DEBUG
        // lifecycles = ['uninitialized', 'created', 'started', 'finished', 'failed', 'not-running'];
        // for (var i = 0; i < repos.length; i++) {
        //   var number = Math.floor(Math.random() * 100);
        //   repos[i].lifecycle = lifecycles[number % lifecycles.length];
        // }

        $scope.data = repos.sort(function(x, y) {
          return x.displayName.localeCompare(y.displayName);
        });
        $scope.builds = [];
        $scope.disabled = [];
        $scope.updatedAt = getCurrentTime();

        function loadStatus(repo) {
          $log.info('making request to: ' + repo.circleApiLink);
          var timeout = 60000;
          $http.get(repo.circleApiLink).then(function(response) {
              var build = processRepoResponse(repo, response);
              if (build) {
                $log.info('build: ' + JSON.stringify(build));
                if (build.lifecycle == 'started' || build.lifecycle == 'created') {
                  timeout = 10000;
                }
              }
              $scope.data = repos.filter(function(r) {
                return r.lifecycle != 'not_running';
              });
              $scope.builds = repos.filter(function(r) {
                return r.lifecycle != 'not_running' && isBuildBranch(r.branch);
              });
              $scope.disabled = repos.filter(function(r) {
                return r.lifecycle == 'not_running';
              });
              $scope.updatedAt = getCurrentTime();

              if (repo.lifecycle != 'not_running') {
                $timeout(function() {
                  loadStatus(repo);
                }, timeout);
              }
          }, function(result) {
            $log.error('unable to get results for: ' + repo);
            $timeout(function() {
              loadStatus(repo);
            }, timeout);
          });
        }

        for ( var i = 0; i < repositories.length; i ++) {
          loadStatus(repos[i]);
        }

      }
    </script>
  </body>

</html>
